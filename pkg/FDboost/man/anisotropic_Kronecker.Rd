% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/constrainedX.R
\name{anisotropic_Kronecker}
\alias{\%A0\%}
\alias{\%A\%}
\alias{anisotropic_Kronecker}
\title{Kronecker product of two base-learners with anisotropic penalty}
\usage{
bl1 \%A\% bl2

bl1 \%A0\% bl2
}
\arguments{
\item{bl1}{base-learner 1, e.g. \code{bbs(x1)}}

\item{bl2}{base-learner 2, e.g. \code{bbs(x2)}}
}
\description{
EXPERIMENTAL!
Kronecker product of two base-learners allowing for anisotropic penalties.
\code{\%A\%} works in the general case, \code{\%A0\%} for the special case where
the penalty in one direction is zero.


}
\details{
When \code{\%O\%} is called with a specification of \code{df} in both base-learners,
e.g. \code{bbs(x1, df = df1) \%O\% bbs(t, df = df2)}, the global \code{df} for the
Kroneckered base-learner is computed as \code{df = df1 * df2}.
And thus the penalty has only one smoothness parameter lambda resulting in an isotropic penalty,
\deqn{P = lambda * [(P1 o I) + (I o P2)],}
with overall penalty \eqn{P}, Kronecker product \eqn{o},
marginal penalty matrices \eqn{P1, P2} and identity matrices \eqn{I}.
(Currie et al. (2006) introduced the generalized linear array model, which has a design matrix that
is composed of the Kronecker product of two marginal design matrices, which was implemented in mboost
as \code{\%O\%}.
See Brockhaus et al. (2015) for the application of array models to functional data.)

In contrast, a Kronecker product with anisotropic penalty is obtained by \code{\%A\%},
which allows for a different amount of smoothness in the two directions.
For example \code{bbs(x1, df = df1) \%A\% bbs(t, df = df2)} results in computing two
different values for lambda for the two marginal design matrices and a global value of
lambda to adjust for the global \code{df}, i.e.
\deqn{P = lambda * [(lambda1 * P1 o I) +  (I o lambda2 * P2)],}
with Kronecker product \eqn{o},
where \eqn{lambda1} is computed individually for \eqn{df1} and \eqn{P1},
\eqn{lambda2} is computed individually for \eqn{df2}  and \eqn{P2},
and \eqn{lambda} is computed such that the global \eqn{df} hold \eqn{df = df1 * df2}.
For the computation of \eqn{lambda1} and \eqn{lambda2} weights specified in the model
call can only be used when the weights, are such that they are specified on the level
of rows and columns of the response matrix Y, e.g. resampling weights on the level of
rows of Y and integration weights on the columns of Y are possible.
If this the weights cannot be separated to blg1 and blg2 all
weights are set to 1 for the computation of \eqn{lambda1} and \eqn{lambda2} which implies that
\eqn{lambda1} and \eqn{lambda2} are equal over
folds of \code{cvrisk}. The computation of the global \eqn{lambda} considers the
specified \code{weights}, such the global \eqn{df} are correct.

The operator \code{\%A0\%} treats the important special case where \eqn{lambda1 = 0} or
\eqn{lambda2 = 0}. In this case it suffices to compute the global lambda and computation gets
faster and arbitrary weights can be specified. Consider \eqn{lambda1 = 0} then the penalty becomes
\deqn{P = lambda * [(1 * P1 o I) +  (I o lambda2 * P2)] = lambda * lambda2 * (I o P2),}
and only one global \eqn{lambda} is computed which is then  \eqn{lambda * lambda2}.

If the \code{formula} in \code{FDboost} contains base-learners connected by
\code{\%O\%}, \code{\%A\%} or \code{\%A0\%},
those effects are not expanded with \code{timeformula}, allowing for model specifications
with different effects in time-direction.
}
\examples{
######## Example for anisotropic penalty
data("viscosity", package = "FDboost")
## set time-interval that should be modeled
interval <- "101"

## model time until "interval" and take log() of viscosity
end <- which(viscosity$timeAll == as.numeric(interval))
viscosity$vis <- log(viscosity$visAll[,1:end])
viscosity$time <- viscosity$timeAll[1:end]
# with(viscosity, funplot(time, vis, pch = 16, cex = 0.2))

## isotropic penalty, as timeformula is kroneckered to each effect using \%O\%
## only for the smooth intercept \%A0\% is used, as 1-direction should not be penalized
mod1 <- FDboost(vis ~ 1 +
                bolsc(T_C, df = 1) +
                bolsc(T_A, df = 1) +
                bols(T_C, df = 1) \%Xc\% bols(T_A, df = 1),
                timeformula = ~ bbs(time, df = 3),
                numInt = "equal", family = QuantReg(),
                offset = NULL, offset_control = o_control(k_min = 9),
                data = viscosity, control=boost_control(mstop = 100, nu = 0.4))
## cf. the formula that is passed to mboost
mod1$formulaMboost

## anisotropic effects using \%A0\%, as lambda1 = 0 for all base-learners
## in this case using \%A\% gives the same model, but three lambdas are computed explicitly
mod1a <- FDboost(vis ~ 1 +
                bolsc(T_C, df = 1) \%A0\% bbs(time, df = 3) +
                bolsc(T_A, df = 1) \%A0\% bbs(time, df = 3) +
                bols(T_C, df = 1) \%Xc\% bols(T_A, df = 1) \%A0\% bbs(time, df = 3),
                timeformula = ~ bbs(time, df = 3),
                numInt = "equal", family = QuantReg(),
                offset = NULL, offset_control = o_control(k_min = 9),
                data = viscosity, control=boost_control(mstop = 100, nu = 0.4))
## cf. the formula that is passed to mboost
mod1a$formulaMboost

## alternative model specification by using a 0-matrix as penalty
## only works for bolsc() as in bols() one cannot specify K
## -> model without interaction term
K0 <- matrix(0, ncol = 2, nrow = 2)
mod1k0 <- FDboost(vis ~ 1 +
                 bolsc(T_C, df = 1, K = K0) +
                 bolsc(T_A, df = 1, K = K0),
                 timeformula = ~ bbs(time, df = 3),
                 numInt = "equal", family = QuantReg(),
                 offset = NULL, offset_control = o_control(k_min = 9),
                 data = viscosity, control=boost_control(mstop = 100, nu = 0.4))
## cf. the formula that is passed to mboost
mod1k0$formulaMboost

## optimize mstop for mod1, mod1a and mod1k0
## ...

## compare estimated coefficients
\dontrun{
par(mfrow=c(4, 2))
plot(mod1, which = 1)
plot(mod1a, which = 1)
plot(mod1, which = 2)
plot(mod1a, which = 2)
plot(mod1, which = 3)
plot(mod1a, which = 3)
funplot(mod1$yind, predict(mod1, which=4))
funplot(mod1$yind, predict(mod1a, which=4))
}
}
\references{
Brockhaus, S., Scheipl, F., Hothorn, T. and Greven, S. (2015):
The functional linear array model. Statistical Modelling, 15(3), 279-300.

Currie, I.D., Durban, M. and Eilers P.H.C. (2006):
Generalized linear array models with applications to multidimensional smoothing.
Journal of the Royal Statistical Society, Series B-Statistical Methodology, 68(2), 259-280.
}

