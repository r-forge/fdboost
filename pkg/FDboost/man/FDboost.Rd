% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/FDboost.R
\name{FDboost}
\alias{FDboost}
\title{Model-based Gradient Boosting for Functional Response}
\usage{
FDboost(formula, timeformula, id = NULL, numInt = "equal", data,
  weights = NULL, offset = NULL, offset_control = o_control(),
  check0 = FALSE, ...)
}
\arguments{
\item{formula}{a symbolic description of the model to be fit.}

\item{timeformula}{formula for the expansion over the index of the response.
For a functional response \eqn{Y_i(t)} typically \code{~bbs(t)} to obtain a smooth
expansion of the effects along \code{t}. In the limiting case that \eqn{Y_i} is a scalar response
use \code{~bols(1)}, which sets up a base-learner for the scalar 1.}

\item{id}{defaults to NULL which means that the response is a matrix with a regular time.
If the response is given in long format for irregular observations, \code{id}
contains the information which observations belong together and must be supplied as a formula,
\code{~nameid}, where the variable \code{nameid} should be contained in \code{nameid}
and contain integers 1, 2, 3, ..., N.}

\item{numInt}{integration scheme for the integration of the loss function.
One of \code{c("equal", "Riemann")} meaning equal weights of 1 or
trapezoidal Riemann weights.
Alternatively a vector of length \code{nrow(response)} containing arbitrary
positive weights can be specified.}

\item{data}{a data frame or list containing the variables in the model.}

\item{weights}{(1) a numeric vector of weights for observational units,
i.e. \code{length(weights)} has to be \code{nrow(response)},
(2) alternatively weights can be specified for single observations then
\code{length(weights)} has to be \code{nrow(response)}*\code{ncol(response)}
per default weights is constantly 1.}

\item{offset}{a numeric vector to be used as offset over the index of the response (optional).
If no offset is specified, per default a smooth time-specific offset is calculated and used
within the model fit. If you do not want to use an offset you can set \code{offset=0}.}

\item{offset_control}{parameters for the calculation of the offset,
defaults to \code{o_control(k_min=20, silent=TRUE)}, see \code{\link{o_control}}.}

\item{check0}{logical, for response observed on a common grid,
check the fitted effects for the sum-to-zero constraint
\eqn{h_j(x_i)(t) = 0} for all \eqn{t} and give warning if it is not fulfilled. Defaults to TRUE.}

\item{...}{additional arguments passed to \code{\link[mboost]{mboost}},
including, \code{family} and \code{control}.}
}
\value{
on object of class \code{FDboost} that inherits from \code{mboost}.
Special \code{\link{predict.FDboost}}, \code{\link{coef.FDboost}} and
\code{\link{plot.FDboost}} methods are available.
The methods of \code{\link[mboost]{mboost}} are available as well,
e.g., \code{\link[mboost]{extract}}.

The \code{FDboost}-object is a named list containing:
\item{...}{all elements of an \code{\link[mboost]{mboost}-object}}
\item{yname}{the name of the response}
\item{ydim}{for a regualr response the dimension of the response matrix}
\item{yind}{the observation points of the response, with its name as attribute}
\item{data}{the data that was used for the model fit}
\item{id}{the id variable of the response}
\item{predictOffset}{the function to predict the smooth offset}
\item{offsetVec}{the offset for one trajectory for regular response and
otherwise the offset for all trajectories}
\item{call}{the call to FDboost}
\item{callEval}{the evaluated function call}
\item{timeformula}{the time-formula}
\item{formulaFDboost}{the formula with which \code{FDboost} was called}
\item{formulaMboost}{the formula with which \code{mboost} was called within \code{FDboost}}
}
\description{
Gradient boosting for optimizing arbitrary loss functions, where component-wise models
are utilized as base-learners in the case of functional response.
Scalar responses are treated as the special case where each functional response has
only one observation.
This function is a wrapper for \code{mboost}'s \code{\link[mboost]{mboost}} and its
siblings to fit models of the general form
\cr \eqn{\xi(Y_i(t)) = \sum j h_j(x_i, t)}, i=1, ..., N, \cr
with a functional (but not necessarily continuous) response \eqn{Y(t)},
transformation function \eqn{\xi}, e.g., the expectation, the median or some quantile,
and partial effects \eqn{h_j(x_i, t)} depending on covariates
and the current index of the response.
Possible effects are, e.g., a smooth intercept \eqn{\beta_0(t)},
effects of functional covariates \eqn{\int X_i(s)\beta(s,t)ds},
smooth and linear effects of scalar covariates \eqn{f(z_i)}, \eqn{z_i \beta(t)}.
}
\details{
The functional response and functional covariates have to be
supplied as N by <number of evaluations> matrices, i.e., each row is one
functional observation. For the model fit the matrix of the functional
response evaluations \eqn{Y_i(t)} are stacked into one long vector.
If it is possible to represent the model as a generalized linear array model
(Currie et al., 2006), the array structure is used for an efficient implementation,
see \code{\link[mboost]{mboost}}. This is only possible if the design
matrix can be written as the Kronecker product of two marginal design
matrices, see Brockhaus et al. (2015) for details.
The Kronecker product of two marignal bases is implemented in R-package mboost
in the function \code{\%O\%}, see ?"\%O\%".

If the response is observed irregularly or sparse it must be supplied
as a vector in long format. In that case the argument \code{id} has
to be specified (as formula!) to define which observations belong to which curve.
In this case the base-learners are built as row tensor-products of marginal base-learners,
see Scheipl et al. (2014), for details on how to set up the effects.
The row tensor product of two marignal bases is implemented in R-package mboost
in the function \code{\%X\%}, see ?"\%X\%".
}
\examples{
######## Example for function-on-scalar-regression
data("viscosity", package = "FDboost")
## set time-interval that should be modeled
interval <- "101"

## model time until "interval" and take log() of viscosity
end <- which(viscosity$timeAll==as.numeric(interval))
viscosity$vis <- log(viscosity$visAll[,1:end])
viscosity$time <- viscosity$timeAll[1:end]
# with(viscosity, funplot(time, vis, pch=16, cex=0.2))

## fit median regression model with 100 boosting iterations,
## step-length 0.4 and smooth time-specific offset
## the factors are in effect coding -1, 1 for the levels
## no integration weights are used!
mod1 <- FDboost(vis ~ 1 + bols(T_C, contrasts.arg = "contr.sum", intercept=FALSE)
               + bols(T_A, contrasts.arg = "contr.sum", intercept=FALSE),
               timeformula=~bbs(time, lambda=100),
               numInt="equal", family=QuantReg(),
               offset=NULL, offset_control = o_control(k_min = 9),
               data=viscosity, control=boost_control(mstop = 100, nu = 0.4))
summary(mod1)
## plot(mod1)
## plotPredicted(mod1, lwdPred=2)

\dontrun{
## find optimal mstop over 5-fold bootstrap, small number of folds for example
## do the resampling on the level of curves
val1 <- validateFDboost(mod1, folds = cv(rep(1, length(unique(mod1$id))), B=5))
## plot(val1)
mstop(val1)
mod1[mstop(val1)]

## find the optimal mstop over 5-fold bootstrap
## using the function cvrisk; be careful to do the resampling on the level of curves
cvm1 <- cvrisk(mod1, folds = cvLong(id = mod1$id, weights = model.weights(mod1), B=5),
               grid = 1:100)
## plot(cvm1)
mstop(cvm1)
}

######## Example for scalar-on-function-regression
data("fuelSubset", package = "FDboost")

## center the functional covariates per observed wavelength
fuelSubset$UVVIS <- scale(fuelSubset$UVVIS)
fuelSubset$NIR <- scale(fuelSubset$NIR)

mod2 <- FDboost(heatan ~ bsignal(UVVIS, uvvis.lambda, knots=40, df=4, check.ident=FALSE)
               + bsignal(NIR, nir.lambda, knots=40, df=4, check.ident=FALSE),
               timeformula=~bols(1), data=fuelSubset)
summary(mod2)
## plot(mod2)

## Example for function-on-function-regression
if(require(fda)){
  data("CanadianWeather", package="fda")
  CanadianWeather$l10precip <- t(log(CanadianWeather$monthlyPrecip))
  CanadianWeather$temp <- t(CanadianWeather$monthlyTemp)
  CanadianWeather$region <- factor(CanadianWeather$region)
  CanadianWeather$month.s <- CanadianWeather$month.t <- 1:12

  ## center the temperature curves per time-point
  CanadianWeather$temp <- scale(CanadianWeather$temp, scale=FALSE)

  ## fit model with cyclic splines over the year
  mod3 <- FDboost(l10precip ~ bols(region, df=2.5, contrasts.arg = "contr.dummy")
                 + bsignal(temp, month.s, knots=11, cyclic=TRUE,
                           df=2.5, boundary.knots=c(0.5,12.5), check.ident=FALSE),
                 timeformula=~bbs(month.t, knots=11, cyclic=TRUE,
                                  df=3, boundary.knots=c(0.5,12.5)),
                                  offset=0, offset_control = o_control(k_min=5),
                  data=CanadianWeather)
 summary(mod3)
 ## plot(mod3, pers=TRUE)
}
}
\author{
Sarah Brockhaus, Torsten Hothorn
}
\references{
Brockhaus, S., Scheipl, F., Hothorn, T. and Greven, S. (2015).
The functional linear array model. Statistical Modelling, 15(3), 279-300.

Currie, I.D., Durban, M., and Eilers P.H.C. (2006),
Generalized linear array models with applications to multidimensional smoothing.
Journal of the Royal Statistical Society, Series B-Statistical Methodology, 68(2), 259-280.

Scheipl, F., Staicu, A.-M., and Greven, S. (2014),
Functional Additive Mixed Models, Journal of Computational and Graphical Statistics,
in press, DOI 10.1080/10618600.2014.901914.
\url{http://arxiv.org/abs/1207.5947}
}
\seealso{
Note that \link{FDboost} calls \code{\link[mboost]{mboost}} directly.
See, e.g., \code{\link[FDboost]{bsignal}} and \code{\link[FDboost]{bbsc}}
for possible base-learners.
}
\keyword{models,}
\keyword{nonlinear}

